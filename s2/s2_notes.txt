part 10: just first "hello world" type project
part 11: overview of compilation process
part 12: primitive types, qualifiers on primitive types.
climits headerfile includes macros for 
cfloat or <float.h> headerfile decines macros for sizes of floats
talking about variable declaration
part 13: input
part 14: functions
part 15: more functions (this time with header files)
Note:

we are now doing multi-file compilations (using header files for functions)
using vscode you will need to change your tasks.json:

the obvious alternative is to use g++ from command line, or create a cmakelists.txt

{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++ build active file",
            "command": "/usr/bin/g++",
            "args": [
                "-g",
                //"${file}",
                "${fileDirname}/*.cpp",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${workspaceFolder}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}

part 16: basic debugging

part 17: uniform initialization (c++11 using braces {} to initialize)

part 18: pointers

part 19: assignment 1, pointer arithmetic functions

part 20: references: He explains it as references are just an alias to a variable (it's the address of)

part 21: assignment 2, arithmetic functions with references

part 22: pass by value, pass by pointer (or address), pass by reference

part 23: const

part 24: const with references and pointers
tip: read from right to left:
conts int CHUNK_SIZE = 512;
const int *ptr = &CHUNK_SIZE; => ptr is a pointer to an int that is const

part 25: const with ref and pointers assignment

part 26: automatic type inference w/ auto

part 27: range based for loop

part 28: range based for loop pt 2

part 29:

part 30:

part 31: inline functions
always prefer an inline function over preprocessor macros as macros can have weird behavior
when viewed with a disassembly debugger inlining turns the assembly code from calling the function
to calling assembly code "inline" that is equivalent to the function, if possible.
replaces the call of the function with the assembly code for the body of the function.
the program then doesn't need to save the return address
no stack memory for arguments is needed
because of this, it may improve the performance.
the inline keyword only makes a request to the compiler, so it's up to the compiler to do it.

part 32: function pointers
pointer that holds the address of a function.
the type is the same as the signature of the function (which is the return type and arguments).
can be used to indirectly invoke the function even if the function name is not known.
used by algorithms and classes for customization.

part 33: namespaces

section 3: memory management
part 34: dynamic memory allocation pt 1
stack - allocated automatically for local variables on a contiguous block of memory
stores temporary variables created by each function (including main() ).  
stack is a last in first out data structure that is managed by the CPU
memory is managed for you when you use the stack.'
The stack grows and shrinks as functions push and pop local variables.
stack variables only exist while the function that created them is running. 
data section - allocated for global and static data
heap - allocated at runtime

all of this memory is taken fro the process address space, which is automatically created when a program is run
dynamic memory allocation - allocating memory at runtime
allocations on the heap have to be managed by the programmer
stack and data section allocations are managed by the runtime

c-style dynamic memory:
malloc - allocate uninitialized memory
calloc - allocated memory and initialize to 0
free - free the allocated memory to prevent a memory leak

p35 - c++ style memory allocation
new - allocates memory on the heap
delete - deallocates memory

malloc vs new
malloc is a function, new is an operator
malloc requries size during allocation, with new it's ascertained from the type
malloc cannot initialize memory, new can
malloc cannot call constructors, new can
malloc returns void pointers that need to be type casted, new returns the correct type of pointer
new can be customized through overloading because it's an operator
when malloc fails to allocate memory returns NULL, new throws an exception on failure

3 methods of allocating in c: malloc, calloc, realloc
1 method of allocating in c++: new

ALWAYS use new to allocate memory when using C++.

p36 - arrays on the heap (using new with arrays)
need to use new with the subscript operator
new <type> [<size>]
e.g. int *p = new int[5]
also need to tuse delete with subscript operator
delete[]
e.g. delete []p

p37 - multi-dimensional arrays on the heap
douchey
