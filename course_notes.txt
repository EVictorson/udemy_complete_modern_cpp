part 10: just first "hello world" type project
part 11: overview of compilation process
part 12: primitive types, qualifiers on primitive types.
climits headerfile includes macros for 
cfloat or <float.h> headerfile decines macros for sizes of floats
talking about variable declaration
part 13: input
part 14: functions
part 15: more functions (this time with header files)
Note:

we are now doing multi-file compilations (using header files for functions)
using vscode you will need to change your tasks.json:

the obvious alternative is to use g++ from command line, or create a cmakelists.txt

{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++ build active file",
            "command": "/usr/bin/g++",
            "args": [
                "-g",
                //"${file}",
                "${fileDirname}/*.cpp",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${workspaceFolder}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}

part 16: basic debugging

part 17: uniform initialization (c++11 using braces {} to initialize)

part 18: pointers

part 19: assignment 1, pointer arithmetic functions

part 20: references: He explains it as references are just an alias to a variable (it's the address of)

part 21: assignment 2, arithmetic functions with references

part 22: pass by value, pass by pointer (or address), pass by reference

part 23: const

part 24: const with references and pointers
tip: read from right to left:
conts int CHUNK_SIZE = 512;
const int *ptr = &CHUNK_SIZE; => ptr is a pointer to an int that is const

part 25: const with ref and pointers assignment

part 26: automatic type inference w/ auto

part 27: range based for loop

part 28: range based for loop pt 2

part 29:

part 30:

part 31: inline functions
always prefer an inline function over preprocessor macros as macros can have weird behavior
when viewed with a disassembly debugger inlining turns the assembly code from calling the function
to calling assembly code "inline" that is equivalent to the function, if possible.
replaces the call of the function with the assembly code for the body of the function.
the program then doesn't need to save the return address
no stack memory for arguments is needed
because of this, it may improve the performance.
the inline keyword only makes a request to the compiler, so it's up to the compiler to do it.

part 32: function pointers
pointer that holds the address of a function.
the type is the same as the signature of the function (which is the return type and arguments).
can be used to indirectly invoke the function even if the function name is not known.
used by algorithms and classes for customization.

part 33: namespaces

section 3: memory management
part 34: dynamic memory allocation pt 1
stack - allocated automatically for local variables on a contiguous block of memory
stores temporary variables created by each function (including main() ).  
stack is a last in first out data structure that is managed by the CPU
memory is managed for you when you use the stack.'
The stack grows and shrinks as functions push and pop local variables.
stack variables only exist while the function that created them is running. 
data section - allocated for global and static data
heap - allocated at runtime

all of this memory is taken fro the process address space, which is automatically created when a program is run
dynamic memory allocation - allocating memory at runtime
allocations on the heap have to be managed by the programmer
stack and data section allocations are managed by the runtime

c-style dynamic memory:
malloc - allocate uninitialized memory
calloc - allocated memory and initialize to 0
free - free the allocated memory to prevent a memory leak

p35 - c++ style memory allocation
new - allocates memory on the heap
delete - deallocates memory

malloc vs new
malloc is a function, new is an operator
malloc requries size during allocation, with new it's ascertained from the type
malloc cannot initialize memory, new can
malloc cannot call constructors, new can
malloc returns void pointers that need to be type casted, new returns the correct type of pointer
new can be customized through overloading because it's an operator
when malloc fails to allocate memory returns NULL, new throws an exception on failure

3 methods of allocating in c: malloc, calloc, realloc
1 method of allocating in c++: new

ALWAYS use new to allocate memory when using C++.

p36 - arrays on the heap (using new with arrays)
need to use new with the subscript operator
new <type> [<size>]
e.g. int *p = new int[5]
also need to tuse delete with subscript operator
delete[]
e.g. delete []p

p37 - multi-dimensional arrays on the heap
douchey

SECTION 4 OBJECT ORIENTED PROGRAMMING

object model:
basic principles that helps us write OO programs:
abstraction
encapsulation
inheritance
polymorphism


p43 - non-static data member initialization
can just initialize members in the class declaration w/
int blah{0};

p44 - this pointer
this points to the object that invoked the member function
compiler implicitly uses this pointer
you can optionally always use the this pointer to access class members from within a class function

if you put a breakpoint in code that access class members and look at disassembly you'll see:
a lea command to load object memory location to register
then register value is assigned to this pointer

can use this pointer to clear up stuff like this:
void Foo(const car &car) {

}

void car::AddPassengers(int passengers) {
	this->passengers = passengers;
	Foo(*this);
}


p45 - constant member functions
const member functions create for read only functions

all member functions that don't modify state should be modified with const qualifier

p46 - static class members
need to be defined in implementation file
often used for things like reference counting

p47 - copy constructor
used to create a copy of an object
copies values of member variables from one object to another
if you don't define a copy constructor, the compiler will synthesize one

Rule of 3
if a user has defined any of the following, they should probably all be defined:
destructor
copy constructor
copy assignment operator

use copy constructors that perform a deep copy when there are member variables that are pointers


p49 - delegating constructors
allows a constructor to invoke another constructor
replacement for common initialization
reduces duplicate initialization code in multiple constructors
(duplication is a common source of introducing bugs)

p50 - default and deleted functions
can explicitly tell the compiler to create a default function.
can explicitly tell compiler to delete a function, for example, the copy constructor
so as to prevent copy construction from happening with the class.

p51 - l-values, r-values and r-value references
l values:
have a name
all variables are l-values
can be assigned values
some expressions return l-values
l-values persist beyond the expression
can create an l-value reference

r-values:
do not have a name
is a temporary variable
cannot be assigned values
some expressions return r-values
do not persist beyond the expression
can create an r-value reference

pre-increment operator returns an l-value
functions that return by value return an r-value
functions that return by reference return an l-value

r-value references:
a reference to a temporary
represents a temporary
created with the && operator
cannot point to l-values
r-value references always bind to temporaries
l-value references always bind to l-values

int &&r1 = 10;	// r-value reference

r-value references when not used with move semantics can be used to detect temporaries

p52 - move sematics basics

copy is implemented through copy constructors
copy of the object is created (either deep or shallow)
wasteful in the case that a copy is created from a temporary
instead, the state can be moved from the source object, which is implemented with move semantics

much faster than deep copies as we don't have to allocate new memory


move constructor

p53 - move semantics 2 (implementation)

rule of 5:
if any of the following are defined you should probably define all of them
destructor
copy constructor
copy assignment operator
move constructor
move assignment operator


p54 - copy elision

technique used by compiler to eliminate temporary objects
by default, all compilers use copy elision
so, for example, in
Integer a = 3;
instead of being called as Integer a = Integer(3), which would require copy or move constructors
it changes it to Integer a(3);
so it uses the parameterized constructor

to turn off copy elision with g++ compiler use:
-fno-elide-constructors

p55 - std::move function

std::move() is always applied to l-values
it simply performs a typecast to an r-value reference
it forces compiler to choose move functions vs copy functions
when an object is moved it goes to an unspecified state
std::move() is used a lot with non-copyable objects (std::unique_ptr)

S5 - operator overloading

p57 - operator overloading pt 1
operator overloading is just syntactic sugar over function calls
when an operator is overloaded as a member function it will take one less argument,
e.g. a binary operator that is overloaded as a member function, the first argument will be the this pointer

if you use a disassembler the operator call will appear in assembly code as just a function call


p61 - operator overloading pt 5 (smart pointer basics)
RAII: resource acquisition is initialization
the lifetime of a resource is bound to a local object
in the object's destructor the resource is destroyed

p62 - smart pointers 2
std::unique_ptr has copy semantics deleted
move semantics are enabled

std::shared_ptr has copy semantics enabled
shared_ptr has reference counting 
underlying resource will only be released when the reference count goes to 0
it is encouraged to ALWAYS use smart pointers to prevent memory leaks in c++

p63 - type conversions 1
performed through casts

c-style cast: 
int a = 5, b = 2;
float f = (float)a/b;

or 
float f = float(a/b);

c++ style (recommended):
float f = static_cast<float>(a/b);

c++ style static cast performs compile time checking
so, trying to cast a char to a float will compile w/ c-style
but will not compile when implemented with c++ style static_cast<>

reinterpret_cast<>

char *p = reinterpret_cast<char*>(&a);

reinterpret_cast does not discard qualifiers (like const), whereas c-style does

YOU SHOULD STRONGLY PREFER C++ STYLE CASTS because:
1. more readable
2. compile time checking
3. easier to search for casts

p64 - type conversions 2

p65 - type conversions 3
Integer a1{5};
// moves primitive type int via move assignment (because it's an r-value) to a1
a1 = 7;

explicit keyword is used to prevent compiler from using implicit conversions w/ constructors
constructors are used by compiler to convert from primitive types to user defined types
if we want to prevent this we use the explicit keyword


p66 - type conversion 4
type conversion operator function
` operator <type>() `

p67 - type conversion 5 initialization vs assignment
assignment requires more function calls that initialization
ALWAYS PREFER INITIALIZATION OVER ASSIGNMENT AS IT'S MORE EFFICIENT

this also applies to member initializer lists in class constructors
always prefer member initializer lists as they're more efficient for the same reasons


S6 - SMART POINTERS
p68
based on the concept of resource acquisition is initialization (RAII)
bids the lifecycle of a resource to a local object
Some people have tried to rename it as "scope-bound resource management" which makes more sense

p69 - unique pointer
unique pointer is just a class wrapper around a raw pointer
unique pointer has explicit constructor, so we cannot use assignment to initialize
we need to use direct initialization instead

std::unique_ptr<Integer> p{GetPointer(value)};

when using unique pointers you can use reset
p.reset(new Integer{value}); // will delete old pointer then take ownership of previous value
need to use reset() instead of assignment operator with unique pointers

unique_ptr.get() retrieves underlying pointer, so you can use it with any function that expects a pointer to the object as opposed to a smart pointer

p70 - shared pointer

p71 - weak pointer

p72 - weak pointer
std::weak_ptr

weak pointer is always initialized with a shared pointer
points to the control block (e.g. ref count) of the shared pointer it's initialized from

cannot directly access control block pointed to by weak_ptr, need to use function expired()
expired() will return true if the ref cnt is 0, otherwise true

p73 - circular references with smart pointers
with shared pointers it's still possible to create circular references and create memory leaks

circular reference memory leaks can be prevented by using weak pointers
weak pointers do not increase the reference count

S7 MORE C++ GOODIES

p74 - enums
enums are used to create a restricted range of values that can be passed to functions

created through enum keyword
created with restricted range of values, called symbolic constants or enumerators
enumerators are internaly represented as undefined integral types
can implicitly convert to an integer, but not the other way around
default value starts from 0, but users can assign any value
enumerators re visible in the scope in which they're defined

for example, if we wanted a function that could take in ints, with each int mapping to a color
we have no way to restrict ourselves to colors that have been defined, resulting in undefined behavior
by using enums we can ensure that we are restricted to using a range of values that have defined
behavior.

PREFER SCOPED ENUMS OVER NON-SCOPED ENUMS IN C++
scoped enum:
enum class Color{RED, GREEN, BLUE}

which is then accessed with the scope resolution operator ::
Color::RED

p76 - strings

p77 - strings assignment 1
implement ToUpper and ToLower functions that operate on strings 

p78 - string streams

e.g. 
int a{5}, b{6};
int sum = a + b;
std::stringstream ss;
ss << "sum of "<< a << " and "<< b <<" is : "<< sum << std::endl;
std::cout<<s<<std::endl;
// clear the contents of the stringstream
ss.str("");
// or can use ss.str(std::string());

p80 - string assignment 2

p81 - user defined literals
literals suffixes are used to force all numeric operands to be of the right type
as opposed to relying on the c++ compiler's rules for promoting / demoting numeric expressions.

user defined literals
a literal is a fixed value that appears directly in the code
creating custom literals provides syntactic shortcuts and increases type safety

e.g.
Temperature temp{82.5} // is this F or c?
Temperature temp{82.5_F}  // use custom literal to specify F

to use a user defined literal need to use 
<return type> operator""_<literal>(<arguments>)

user defined literals should always being with an underscore
you cannot redefine the meaning of built in literal suffixes
only the following types can be suffixed to make a user defined literal:
unsigned long long, long double, const char*, char
literal operator functions cannot be member functions, they must be global

literal types are those that are allowed with constant expressions

p82 - constexpr
used to represent and expression that is constant
causes expressions to possibly be evaluated at compile time
can be applied to variable declarations or functions
may increase the performance of the code as computation is done at compile time

const vs constexpr:
initialization of a const variable can be deferred until runtime
a constexpr variable must be initialized at compile time
all constexpr variables are const, but not the other way around

use const keyword to indicate the value cannot be modified
use constexpr keyword to create expressions that can be evaluated at compile time

p83 - std::initializer_list
lightweight proxy object that represents an array of objects
constructed automatically from a braced list of elements
it's not a true container, but has similar behavior
provides access to its elements through iterators
defined in <initializer_list> header file

p84 - vectors
dynamic arrays

p85 - string assignment 3

p86 - C++ unions
gives the ability to represent all the members in the same memory
just like a structure or class, except everything shares the same memory
thus, it saves space, which can be useful for embedded platforms
several disadvantages:
no way to know what type it holds
nested types with non-default constructors delete the default constructor of the union
cannot assign objects of user-defined types directly to a union member
user defined types are not destroyed implicitly
cannot have a base class
cannot derive from a union

S8 OBJECT ORIENTED PROGRAMMING

p88 - source code example
p89 - Inheritance and composition

in OOP the system is made up of objects
objects are instances of a class
classes and objects are related
collaboration between objects
define the bevahior of the system

Composition - object is composed in another object
represents a "has a" relationship
reuse

Inheritace - class inherits the features of another class
reuse and inherit behavior
represents a "is a " relationship

p90 - inheritance access modifiers

access modifiers
class Base{}

class child : public Base{}
-> only public and protected members of base are accessible in child

class child : private Base{}
-> all members of the base are inherited as private members in child
-> private members of base are inherited but are not accessible

class child : protected Base{}
-> protected and public members of base are inherited as protected members in child

Ojbect construction:
constructors execute from base to child
destructors execute from child to base
base data members will be part of the child object

p91 - overview of banking project (project pt 1)


p94 - inherited constructors

p95 - virtual keyword

p96 - virtual mechanism internals
polymorphism:
different forms of the function are provided
the call is resolved at compile time or runtime
if resolved at compile time it's called compile time polymorphism, or compile time binding
function overloading, operator overloading, and templates are examples of compile time polymorphism

sometimes we don't know until runtime which function should be invoked
this is runtime polymorphism or dynamic binding
implemented through virtual mechanism
compiler inserts code to invoke the correct function at runtime
automatically generated through the virtual keyword
such functions are called polymorphic functions
should be invoked only through a pointer or reference
