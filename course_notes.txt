part 10: just first "hello world" type project
part 11: overview of compilation process
part 12: primitive types, qualifiers on primitive types.
climits headerfile includes macros for 
cfloat or <float.h> headerfile decines macros for sizes of floats
talking about variable declaration
part 13: input
part 14: functions
part 15: more functions (this time with header files)
Note:

we are now doing multi-file compilations (using header files for functions)
using vscode you will need to change your tasks.json:

the obvious alternative is to use g++ from command line, or create a cmakelists.txt

{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++ build active file",
            "command": "/usr/bin/g++",
            "args": [
                "-g",
                //"${file}",
                "${fileDirname}/*.cpp",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${workspaceFolder}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}

part 16: basic debugging

part 17: uniform initialization (c++11 using braces {} to initialize)

part 18: pointers

part 19: assignment 1, pointer arithmetic functions

part 20: references: He explains it as references are just an alias to a variable (it's the address of)

part 21: assignment 2, arithmetic functions with references

part 22: pass by value, pass by pointer (or address), pass by reference

part 23: const

part 24: const with references and pointers
tip: read from right to left:
conts int CHUNK_SIZE = 512;
const int *ptr = &CHUNK_SIZE; => ptr is a pointer to an int that is const

part 25: const with ref and pointers assignment

part 26: automatic type inference w/ auto

part 27: range based for loop

part 28: range based for loop pt 2

part 29:

part 30:

part 31: inline functions
always prefer an inline function over preprocessor macros as macros can have weird behavior
when viewed with a disassembly debugger inlining turns the assembly code from calling the function
to calling assembly code "inline" that is equivalent to the function, if possible.
replaces the call of the function with the assembly code for the body of the function.
the program then doesn't need to save the return address
no stack memory for arguments is needed
because of this, it may improve the performance.
the inline keyword only makes a request to the compiler, so it's up to the compiler to do it.

part 32: function pointers
pointer that holds the address of a function.
the type is the same as the signature of the function (which is the return type and arguments).
can be used to indirectly invoke the function even if the function name is not known.
used by algorithms and classes for customization.

part 33: namespaces

section 3: memory management
part 34: dynamic memory allocation pt 1
stack - allocated automatically for local variables on a contiguous block of memory
stores temporary variables created by each function (including main() ).  
stack is a last in first out data structure that is managed by the CPU
memory is managed for you when you use the stack.'
The stack grows and shrinks as functions push and pop local variables.
stack variables only exist while the function that created them is running. 
data section - allocated for global and static data
heap - allocated at runtime

all of this memory is taken fro the process address space, which is automatically created when a program is run
dynamic memory allocation - allocating memory at runtime
allocations on the heap have to be managed by the programmer
stack and data section allocations are managed by the runtime

c-style dynamic memory:
malloc - allocate uninitialized memory
calloc - allocated memory and initialize to 0
free - free the allocated memory to prevent a memory leak

p35 - c++ style memory allocation
new - allocates memory on the heap
delete - deallocates memory

malloc vs new
malloc is a function, new is an operator
malloc requries size during allocation, with new it's ascertained from the type
malloc cannot initialize memory, new can
malloc cannot call constructors, new can
malloc returns void pointers that need to be type casted, new returns the correct type of pointer
new can be customized through overloading because it's an operator
when malloc fails to allocate memory returns NULL, new throws an exception on failure

3 methods of allocating in c: malloc, calloc, realloc
1 method of allocating in c++: new

ALWAYS use new to allocate memory when using C++.

p36 - arrays on the heap (using new with arrays)
need to use new with the subscript operator
new <type> [<size>]
e.g. int *p = new int[5]
also need to tuse delete with subscript operator
delete[]
e.g. delete []p

p37 - multi-dimensional arrays on the heap
douchey

SECTION 4 OBJECT ORIENTED PROGRAMMING

object model:
basic principles that helps us write OO programs:
abstraction
encapsulation
inheritance
polymorphism


p43 - non-static data member initialization
can just initialize members in the class declaration w/
int blah{0};

p44 - this pointer
this points to the object that invoked the member function
compiler implicitly uses this pointer
you can optionally always use the this pointer to access class members from within a class function

if you put a breakpoint in code that access class members and look at disassembly you'll see:
a lea command to load object memory location to register
then register value is assigned to this pointer

can use this pointer to clear up stuff like this:
void Foo(const car &car) {

}

void car::AddPassengers(int passengers) {
	this->passengers = passengers;
	Foo(*this);
}


p45 - constant member functions
const member functions create for read only functions

all member functions that don't modify state should be modified with const qualifier

p46 - static class members
need to be defined in implementation file
often used for things like reference counting

p47 - copy constructor
used to create a copy of an object
copies values of member variables from one object to another
if you don't define a copy constructor, the compiler will synthesize one

Rule of 3
if a user has defined any of the following, they should probably all be defined:
destructor
copy constructor
copy assignment operator

use copy constructors that perform a deep copy when there are member variables that are pointers


p49 - delegating constructors
allows a constructor to invoke another constructor
replacement for common initialization
reduces duplicate initialization code in multiple constructors
(duplication is a common source of introducing bugs)

p50 - default and deleted functions
can explicitly tell the compiler to create a default function.
can explicitly tell compiler to delete a function, for example, the copy constructor
so as to prevent copy construction from happening with the class.

p51 - l-values, r-values and r-value references
l values:
have a name
all variables are l-values
can be assigned values
some expressions return l-values
l-values persist beyond the expression
can create an l-value reference

r-values:
do not have a name
is a temporary variable
cannot be assigned values
some expressions return r-values
do not persist beyond the expression
can create an r-value reference

pre-increment operator returns an l-value
functions that return by value return an r-value
functions that return by reference return an l-value

r-value references:
a reference to a temporary
represents a temporary
created with the && operator
cannot point to l-values
r-value references always bind to temporaries
l-value references always bind to l-values

int &&r1 = 10;	// r-value reference

r-value references when not used with move semantics can be used to detect temporaries

p52 - move sematics basics

copy is implemented through copy constructors
copy of the object is created (either deep or shallow)
wasteful in the case that a copy is created from a temporary
instead, the state can be moved from the source object, which is implemented with move semantics

much faster than deep copies as we don't have to allocate new memory


move constructor

p53 - move semantics 2 (implementation)

rule of 5:
if any of the following are defined you should probably define all of them
destructor
copy constructor
copy assignment operator
move constructor
move assignment operator


p54 - copy elision

technique used by compiler to eliminate temporary objects
by default, all compilers use copy elision
so, for example, in
Integer a = 3;
instead of being called as Integer a = Integer(3), which would require copy or move constructors
it changes it to Integer a(3);
so it uses the parameterized constructor

to turn off copy elision with g++ compiler use:
-fno-elide-constructors

p55 - std::move function

std::move() is always applied to l-values
it simply performs a typecast to an r-value reference
it forces compiler to choose move functions vs copy functions
when an object is moved it goes to an unspecified state
std::move() is used a lot with non-copyable objects (std::unique_ptr)

S5 - operator overloading

p57 - operator overloading pt 1
operator overloading is just syntactic sugar over function calls
when an operator is overloaded as a member function it will take one less argument,
e.g. a binary operator that is overloaded as a member function, the first argument will be the this pointer

if you use a disassembler the operator call will appear in assembly code as just a function call


p61 - operator overloading pt 5 (smart pointer basics)
RAII: resource acquisition is initialization
the lifetime of a resource is bound to a local object
in the object's destructor the resource is destroyed

p62 - smart pointers 2
std::unique_ptr has copy semantics deleted
move semantics are enabled

std::shared_ptr has copy semantics enabled
shared_ptr has reference counting 
underlying resource will only be released when the reference count goes to 0
it is encouraged to ALWAYS use smart pointers to prevent memory leaks in c++

p63 - type conversions 1
performed through casts

c-style cast: 
int a = 5, b = 2;
float f = (float)a/b;

or 
float f = float(a/b);

c++ style (recommended):
float f = static_cast<float>(a/b);

c++ style static cast performs compile time checking
so, trying to cast a char to a float will compile w/ c-style
but will not compile when implemented with c++ style static_cast<>

reinterpret_cast<>

char *p = reinterpret_cast<char*>(&a);

reinterpret_cast does not discard qualifiers (like const), whereas c-style does

YOU SHOULD STRONGLY PREFER C++ STYLE CASTS because:
1. more readable
2. compile time checking
3. easier to search for casts

p64 - type conversions 2

p65 - type conversions 3
Integer a1{5};
// moves primitive type int via move assignment (because it's an r-value) to a1
a1 = 7;

explicit keyword is used to prevent compiler from using implicit conversions w/ constructors
constructors are used by compiler to convert from primitive types to user defined types
if we want to prevent this we use the explicit keyword


p66 - type conversion 4
type conversion operator function
` operator <type>() `

p67 - type conversion 5 initialization vs assignment
assignment requires more function calls that initialization
ALWAYS PREFER INITIALIZATION OVER ASSIGNMENT AS IT'S MORE EFFICIENT

this also applies to member initializer lists in class constructors
always prefer member initializer lists as they're more efficient for the same reasons


S6 - SMART POINTERS
p68
based on the concept of resource acquisition is initialization (RAII)
bids the lifecycle of a resource to a local object
Some people have tried to rename it as "scope-bound resource management" which makes more sense

p69 - unique pointer
unique pointer is just a class wrapper around a raw pointer
unique pointer has explicit constructor, so we cannot use assignment to initialize
we need to use direct initialization instead

std::unique_ptr<Integer> p{GetPointer(value)};

when using unique pointers you can use reset
p.reset(new Integer{value}); // will delete old pointer then take ownership of previous value
need to use reset() instead of assignment operator with unique pointers

unique_ptr.get() retrieves underlying pointer, so you can use it with any function that expects a pointer to the object as opposed to a smart pointer

p70 - shared pointer

p71 - weak pointer

p72 - weak pointer
std::weak_ptr

weak pointer is always initialized with a shared pointer
points to the control block (e.g. ref count) of the shared pointer it's initialized from

cannot directly access control block pointed to by weak_ptr, need to use function expired()
expired() will return true if the ref cnt is 0, otherwise true

p73 - circular references with smart pointers
with shared pointers it's still possible to create circular references and create memory leaks

circular reference memory leaks can be prevented by using weak pointers
weak pointers do not increase the reference count

S7 MORE C++ GOODIES

p74 - enums
enums are used to create a restricted range of values that can be passed to functions

created through enum keyword
created with restricted range of values, called symbolic constants or enumerators
enumerators are internaly represented as undefined integral types
can implicitly convert to an integer, but not the other way around
default value starts from 0, but users can assign any value
enumerators re visible in the scope in which they're defined

for example, if we wanted a function that could take in ints, with each int mapping to a color
we have no way to restrict ourselves to colors that have been defined, resulting in undefined behavior
by using enums we can ensure that we are restricted to using a range of values that have defined
behavior.

PREFER SCOPED ENUMS OVER NON-SCOPED ENUMS IN C++
scoped enum:
enum class Color{RED, GREEN, BLUE}

which is then accessed with the scope resolution operator ::
Color::RED

p76 - strings

p77 - strings assignment 1
implement ToUpper and ToLower functions that operate on strings 

p78 - string streams

e.g. 
int a{5}, b{6};
int sum = a + b;
std::stringstream ss;
ss << "sum of "<< a << " and "<< b <<" is : "<< sum << std::endl;
std::cout<<s<<std::endl;
// clear the contents of the stringstream
ss.str("");
// or can use ss.str(std::string());

p80 - string assignment 2

p81 - user defined literals
literals suffixes are used to force all numeric operands to be of the right type
as opposed to relying on the c++ compiler's rules for promoting / demoting numeric expressions.

user defined literals
a literal is a fixed value that appears directly in the code
creating custom literals provides syntactic shortcuts and increases type safety

e.g.
Temperature temp{82.5} // is this F or c?
Temperature temp{82.5_F}  // use custom literal to specify F

to use a user defined literal need to use 
<return type> operator""_<literal>(<arguments>)

user defined literals should always being with an underscore
you cannot redefine the meaning of built in literal suffixes
only the following types can be suffixed to make a user defined literal:
unsigned long long, long double, const char*, char
literal operator functions cannot be member functions, they must be global

literal types are those that are allowed with constant expressions

p82 - constexpr
used to represent and expression that is constant
causes expressions to possibly be evaluated at compile time
can be applied to variable declarations or functions
may increase the performance of the code as computation is done at compile time

const vs constexpr:
initialization of a const variable can be deferred until runtime
a constexpr variable must be initialized at compile time
all constexpr variables are const, but not the other way around

use const keyword to indicate the value cannot be modified
use constexpr keyword to create expressions that can be evaluated at compile time

p83 - std::initializer_list
lightweight proxy object that represents an array of objects
constructed automatically from a braced list of elements
it's not a true container, but has similar behavior
provides access to its elements through iterators
defined in <initializer_list> header file

p84 - vectors
dynamic arrays

p85 - string assignment 3

p86 - C++ unions
gives the ability to represent all the members in the same memory
just like a structure or class, except everything shares the same memory
thus, it saves space, which can be useful for embedded platforms
several disadvantages:
no way to know what type it holds
nested types with non-default constructors delete the default constructor of the union
cannot assign objects of user-defined types directly to a union member
user defined types are not destroyed implicitly
cannot have a base class
cannot derive from a union

S8 OBJECT ORIENTED PROGRAMMING

p88 - source code example
p89 - Inheritance and composition

in OOP the system is made up of objects
objects are instances of a class
classes and objects are related
collaboration between objects
define the bevahior of the system

Composition - object is composed in another object
represents a "has a" relationship
reuse

Inheritace - class inherits the features of another class
reuse and inherit behavior
represents a "is a " relationship

p90 - inheritance access modifiers

access modifiers
class Base{}

class child : public Base{}
-> only public and protected members of base are accessible in child

class child : private Base{}
-> all members of the base are inherited as private members in child
-> private members of base are inherited but are not accessible

class child : protected Base{}
-> protected and public members of base are inherited as protected members in child

Ojbect construction:
constructors execute from base to child
destructors execute from child to base
base data members will be part of the child object

p91 - overview of banking project (project pt 1)


p94 - inherited constructors

p95 - virtual keyword

p96 - virtual mechanism internals
polymorphism:
different forms of the function are provided
the call is resolved at compile time or runtime
if resolved at compile time it's called compile time polymorphism, or compile time binding
function overloading, operator overloading, and templates are examples of compile time polymorphism

sometimes we don't know until runtime which function should be invoked
this is runtime polymorphism or dynamic binding
implemented through virtual mechanism
compiler inserts code to invoke the correct function at runtime
automatically generated through the virtual keyword
such functions are called polymorphic functions
should be invoked only through a pointer or reference

through virtual mechanism the compiler inserts code to invoke the correct function at runtime

when compiler compiles a class with virtual functions it creates an array of pointers to virtual functions
virtual table is created that contains the addresses of virtual functions
non-virtual functions do not appear in the virtual table
the starting address of virtual table is stored in special member variable called the virtual pointer
the virtual pointer is automatically created by the compiler if the class has virtual functions

if instead we create a local object, we create a derived object on the heap with a pointer of type
base class, pointing to a derived class, the derived destructor will not be called.
To fix this we need to declare the base class destructor to be virtual

p98 - override and final specifier

if the class is marked as final it cannot be derived from

we can explicitly tell the compiler to override a base class function with the override specifier
it is considered good practice to use the override specifier anytime we override a base class function

p99 - upcasting and downcasting

upcasting is when we assign a child class to a base class object pointer or reference
we can then call the child class methods through the base class pointer or reference

if we assign a concrete child to concrete base the compiler will perform object slicing:
object slicing is when the compiler deliberately removes some part of an object
occurs when a child class object is assigned to a concrete base class object
since the size of the child class object may be more than its base, some part of the memory may get overwritten
to prevent this, the compiler slices the child object, effectively removing the memory that contains its attributes
the object is then copied into the base object

to prevent object slicing we use a pointer.

downcasting is when we cast a base class pointer to a child class pointer
e.g.
Checking *pChecking = static_cast<Checking> *Account;


p100 - RTTI basics
RTTI = run-time type information
used by including typeinfo header and invoking typeid()
or alternatively checking if dynamic_casting is possible
should be avoided when possible

p101 - RTTI operators
typid() or dynamic_cast

p102 - abstract classes
an abstract class is specified by creating atleast one pure virtual function in the class
e.g. virtual Foo() = 0; (marked with the pure specifier =0)
abstract classes can contain other members (data, non-virtual functions, etc)
they cannot be instantiated, but can be used through a pointer or reference
abstract classes establish a contract with clients
they are used for creating an interface

pure virtual function is specified by marking with =0
usually does not have an implementation
cannot be invoked
do not have an entry in the vtable
must be overriden by the derived classes


p103 multiple (diamond) inheritance
without virtual inheritance diamond inheritance will instantiate the base class twice

e.g. stream base class, child classes from stream, outputstream and input stream
iostream is then derived from both outputstream and inputstream

if we specify outputstream and inputstream to inherit from stream virtually we avoid the double
instantiation issue
e.g.
class InputStream : virtual public Stream {}

S9 - EXCEPTION HANDLING

p104 exception handling basics

try:
creates a scope / block and exception causing code appears here
can contain other try-catch statements

throw:
throws an exception from the try block
exception is object that is constructed in throw statement

catch:
handler that catches the exception object
should appear just after the try block
multiple catch blocks can exist

p105 - multiple catch blocks

there should always be as many catch blocks as throw statements
OR use one that catches base class std::exception

p106 - stack unwinding
with exception handling, if an exception is thrown, code that calls delete on an object afterwards
may never be called.

to prevent this use RAII (smart pointers)

p107 - nested exceptions
nested exceptions allow us to rethrow exceptions up a level with more detailed information

p108 - constructor and destructor exceptions
if exception is thrown in constructor to a pointer, destructor will not be called
they will be called for concrete objects (not for pointer objects)
- another reason to use smart pointers and not raw pointers with exception handling

destructor should not call exceptions
the reason being because of stack unwinding

p109 - noexcept keyword

keyword applied to both function definition and declaration
indicates that the function does not throw exceptions
allows compiler to optimize function code because it does not need to generate stack unwinding code
an exception from such function terminates the program
- stack may or may not be unwound

in c++11 onwards destructors are implicitly keyworded with noexcept
meaning destructors will not throw exceptions

functions that are sure not to throw exceptions should be marked noexcept
if a function invokes any library function it is dangerous to mark it noexcept

noexcept is also an operator that accepts an expression that will return true or false based on inputs 
by default noexcept means noexcept(true)
noexcept(false) means the function can throw exceptions

we can use noexcept() to check if a function should be able to throw exceptions based on 
whether other functions can throw exceptions
e.g.

void Test(int x) {
  throw x;
}

// at compile time will check exception specification of Test(x) and apply it to sum()
int sum(int x, int y) noexcept(noexcept(Test(x)) {
  Test(x);
  return x + y;
}


S10 - FILE INPUT AND OUTPUT

p110 - raw string literals

used to prevent recognition of special characters in strings

C++11 provides raw string literals so that special characters are ignored
such as the case when we have:
e.g. std::string filename{"C:\temp\newfile.txt"};
this will parse a tab (\t) and newline (\n)
in order to get around this c++11 has raw string liters:

std::string filename{R"(C:\temp\newfile.txt")};

p111 - filesystem library (this is marked as deprecated, so let's skip)

filesystem library is introduced in C++17
because it is not yet finalized (as of c++17) it resides in the experimental directory
#include <experimental/filesystem>

p112 - file IO

ofstream - write to an output stream
ifstream - read from an input stream
fstream - write / read strea,

must include <fstream> header

all classes can be used for both text and binary IO
is_open() function returns true or false based on if it's been opened

p113 - error handling

p114 - copy utility example

p115 - character io and seeking

p116 - binary file io

p117 - assignment 1
implement binary version of utility example

p118 - assignment 2
modified version of assignment 1

S11 TEMPLATES

p120 - source code example
p121 - introduction to templates
useful for generic programming
such components can be reused in different situations
creates high performance algorithms and classes
compile time, no runtime costs are involved
libraries sutch as ATL, WTL, boost, POCO, ACE, use templates for implementation

function templates
function that accepts template type arguments
always begin with template keyword
template type argument is called type name
can accept any type
the template type can also be used as the return type
e.g.
template<typename T>
T Function(T arg) {
}

p122 - assignment 1

p123 - template argument deduction
template argument deduction is the process of deducing the types in a template
each function argument is examined
the corresponding type argument is deduced from the argument
type conversions are not performed
after deduction, the template is instantiated
override deduction by specifying types in template argument list

template instantiation:
a template function or class only acts as a blueprint
the compiler generates code from the blueprint at compile time
known as template instantiation
it occurs implicitely when:
- a function template is invoked
- taking address of a function template
- use explicit instatiation of a function template
- create explicit specialization of a function template
for template instantiation to work the full definition of the template should be available
for this reason, templates are defined in header files (definition implemented in header file)

p124 - use a disassembler to look at the assembly code from the previous assignment
Note what happens if the function template is not invoked.

can use disassembler with:
objdump -d -S <path_to_binary>

T ArraySum(T *parr, int arrsize) {
 acd:	55                   	push   %rbp
 ace:	48 89 e5             	mov    %rsp,%rbp
 ad1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 ad5:	89 75 e4             	mov    %esi,-0x1c(%rbp)
    T sum{};
 ad8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    for (int i=0; i<arrsize; ++i) {
 adf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 ae6:	8b 45 fc             	mov    -0x4(%rbp),%eax
 ae9:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
 aec:	7d 1f                	jge    b0d <_Z8ArraySumIiET_PS0_i+0x40>
        sum += parr[i];
 aee:	8b 45 fc             	mov    -0x4(%rbp),%eax
 af1:	48 98                	cltq   
 af3:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
 afa:	00 
 afb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 aff:	48 01 d0             	add    %rdx,%rax
 b02:	8b 00                	mov    (%rax),%eax
 b04:	01 45 f8             	add    %eax,-0x8(%rbp)
    for (int i=0; i<arrsize; ++i) {
 b07:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 b0b:	eb d9                	jmp    ae6 <_Z8ArraySumIiET_PS0_i+0x19>
    return sum;
 b0d:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
 b10:	5d                   	pop    %rbp
 b11:	c3                   	retq 

I honestly can't see what's different other than they just don't get called.


p125 - explicit specialization

template specialized for a particular type
provides correct semantics for some datatype
or implement an algorithm optimally for a specific type
explicitly specialized functions must be defined in a .cpp file
primary template definition should occur before specialization



p126 - nontype template arguments
expression that is computed at compile time within a template argument list
must be a constant expression (addresses, references, integrals, nullptr, enums)
part of the template type
used by std::being and std::end functions

p127 - assignment 3

p128 - perfect forwarding
a function template acting as a member function in a class is known as a member template

p129 - perfect forwarding pt2
std::forward<>() is used to ensure that the argument type is preserved while forwarding it to initialize attributes

perfect forwarding: information about the type is preserved when it is forwarded to the next function call
when you pass things by name some information abou the type will be lost unless perfect forwarding is used


p130 - variadic templates 1
variadic templates can be simplified with c++17 fold expressions

ellipses <...> specify a variadic template

p132 - assignment 4
create a templated factory method

p133 - class templates

p134 - class template explicit specialization 1

p135 - class template explicit specialization 2

p136 - assignment 5

p137 - class template partial specialization

p138 - typedef, type alias, alias templates

typedef:
introduces a name for an existing type
this name becomes a synonym of that type
useful to construct shorter or more meaningful names for existing types
simplifies declarations of some types (e.g. function pointers and templates)
implementation details that may change can be encapsulated
 
std::string is a typedef of basicstring

e.g.
typedef unsigned int UINT;
UINT val{};

typedef long long LLONG;
LLONG elem{};

typdef std::vector<std::<list<Employee>> Teams;
Teams testingTeams;
Teams::iterator it = testingTeams.begin();

// can also be used for function pointers
typedef const char *(*ErrorFN)(int);
ErrorFn pfn = GetErrorMessage;

c++11 introduced type alias:
creates a name that is a synonym of existing type
does not introdue a new type
same as typedef declaration
created through the using keyword

e.g.
using identifier = type;

using UINT = unsigned int;
UINT val{};

using LLONG = long long;
LLONG elem{};

using Teams = std::vector<std::list<Employee>>;
Teams testingTeams;
Teams::iterator it = testingTeams.begin();

using Errorfn = const char *(*)(int);
ErrorFn pfn = GetErrorMessage;

p139 - type traits

c++11 introduced type traits, giving the ability to introspect at compile time
type traits give the ability to introspect
 - find the characteristics of a type at compile time
 - transform the properties of the type
useful in template metaprogramming
yields highly optimized code
will either return a boolean or a type when inspecting types
provides template-based interface and defined in header <type_traits>
some traits require support from the compiler
- compiler provides intrinsics for such traits

type traits are often used in templates for type introspection

p140 - static assertion

static_assert is new kind of declaration fo evaluating expressions
accepts an expression and a user defined message
used for testing an expression at compile time
if the expression returns false, the copiler displays the specified message and compilation fails


S12 LAMBDA EXPRESSIONS

p142 - callbacks revisited - function pointers

motivation:
like accepting a function pointer, but function pointers are called by address, meaning they can't
be optimized (inlined)

p143 - function objects
function objects are objects with an overloaded function call operator, also called a functor
call to overloaded function call operator resembles a global function call
can be used as a callback instead of function pointers
more efficient than function pointers
function objects are usually implemented as structures

function pointer vs function object
function pointer is invoked through a pointer, funtion object is invoked through an object
fcn pointer is dynamic in nature, fcn object is static in nature
fcn pointer can be specified at runtime, fcn object must be specified at compile time
fcn pointer is difficult to optimize, fcn object is easy to optimize
fcn pointers are slow, fcn objects are fast
fcn pointers cannot store state, fcn objects can store state

in c++11 an even better way is through lambda expressions

p144 - lambda expressions
defines an anonymous function object
just a syntactic shortcut for a function object
can be passed as an argument to a function that accepts a function object
can accept parameters and return values

typically encapsulates a few lines of code
behaves like a normal function when invoked
replaces function objects
internally, implemented as a nameless function object
used auto to provide an explicit name

syntax: [] (<args>) { }

[lambda introducer / capture clause]
(arguments)
mutable specification
exception specification
-> trailing return type syntax
{ lambda body }

p145 - lambda expression internals
it's basically just a function object (functor)

p146 - lambda epxression capture lis1

p147 - lambda expression capture list2
- specifies what variables to capture to be passed into the lambda expression (by ref or value)
to specify by ref [&val]()
to specify by value [val]()

to capture all variables by ref (declared before the expression):
[&]()
to capture all variables by value (declared before the expression):
[=]()

to capture all variables by reference, except some by value:
[&, =val]()


p148 - lambda expressions capture list 3
in order to capture class member variables, need to capture the this pointer
[this]() {

}

if a lambda expression has an empty capture list it decomposes into a function pointer

p149 - generalized lambda capture
it is an enhancement to lambda expression introduced in c++14
this feature allows creation of new variables in the capture clause
the tpe of these variables is deduced from the type produced by the expression
consequently, these variables must always be initialized
if the initializer expression is a variable, the new variable can have the same or different name
to create a reference, you have to use operator & before the variable name


p150 - lambda expressions assignment


S13 STANDARD TEMPLATE LIBRARY

p151 - intro to STL
standard template library
heart of the standard library for c++
provides fast and reusable containers and algorithms
relies heavily on templates, almost every component in the STL is a template

core components:
container classes, algorithms and iterators
container classes represent data
algorithms represent operations on the data
iterators serve as the glue between containers and algorithms
also include classes for concurency, random numbers, regular expressions, utilities, etc.

why use STL?
leads to quicker development time because you don't need to create the data structures
reliable
portable
efficient and fast
accurate
makes code more readable
lower maintenance because you don't need to maintain those data structures

container types:
sequential containers
associative containers
unordered containers

all containers provide a function size() to get the size of the container
clear()
begin()
end()
default allocator
all use allocator for memory management

p152 - std::array
thin wrapper over c-style static array
supports iterators
knows about its size
provides random access
can be used with c functions
std::array cannot grow (created at compile time)

the biggest advantage of using std::array is that it knows about its size
can access by using either subscript operators or iterators

iterators:
pointer like objects
used to access elements of container by position
proved overloaded overats such as ++, --, *, etc
created through begin() and end() functions (present in all containers)
begin() returns iterator at first element of container
end() returns iterator at element just past the end of the container

p153 - std::vector

behaves like a dynamic array
grows automatically
efficient for addition / removal at the end of the vector
provides random access
not good for insertion / deletion

p154 - std::deque

short for double ended queue
efficient for addition/removal at both ends
grows automatically
provides random access
not good for insertion / deletion except at the ends

p155 - std::list and forward_list
std::list :
implemented as a two-way linked list
linked list consists of nodes, each node has a pointer to the next and previous node
efficient for insertion / deletion anywhere
does not provide random access

std::forward_list : 
implemented as a one-way linked list
has a small memory footprint
efficient for insertion / deletion
does not provide support for size
elements are always added at the front

p157 - std::set and std::multiset (associative containers)
a set is internally implemented as a binary tree
elements are stored in sorted order (< and > )
values act as keys
provides for fast search
no random access
elements cannot be modified directly

p158 - std::map and std::multimap
implemented as a binary tree
stores a pair that conatins a key and value
elements are stored in a sorted order based on a key
provides fast search
no random access
keys cannot be modified directly, but values can be

p160 - unordered containers
associated containers implemented as hash tables (not binary trees like sorted ones)
values are hashed and stored in undefined order
fast search, insertion/deletion, but may degrade over a period of time
std::unordered_set stores values that act as keys for hashing
std::unordered_map stores pairs (first is used to compute hash)
iterators are constant (cannot modify value through the iterator)

implementaiton:
hash table is dynamic array, where each element in array is known as a bucket or slot
each element that's inserted passes through the hash function, which represents a key
or position in the hash table 
most imeplementations have the buckets hold a pointer to a linked list
this allows inserting elements that have the same calculated value from the hash function
when there are too many collisions in a hash table performance degrades

load factor = entries / capacity

p164  - big O notation and performance of containers
complexity:
amount of time taken by an algorithm to run for input of size n
commonly represented through big O notation
O(1) = constant time
O(n) = linear time
- gives rough idea about the performance of an algorithm

summary:
use vector for random access, but not insertion and deletion
deque is preferable when elements need to be inserted and removed from both ends
use list if frequent insertions and deletions are required
- use forward_list for memory constrained systems
use associative containers if lookup / search is important
favour unordered containersr if elements need not be ordered, else use set/map

p165 - algorithms 1

user objectst and containers:
compilers may define certain rules for user defined objects if they ahve to be stored in containers
these are mostly about certain operators that have to be overloaded for the user objects
generally, your objects should have the following operators overloaded: < > != ==
these operators are used by various containers for sorting and searching

algorithms:
STL provies algorithms for common tasks
- sorting, removing, searching, numeric tasks, etc
more optimized than handwritten loops
work with all containers regardless of the data type
several algorithms can be customized through user-defined operations
some containers provide specialized versions of algorithms:
- list provides sort and remove
- associative containers provide lower_bound, upper_bound, find
most algorithms reside in <algorithm> header




S14 CONCURRENCY

p176 - task based concurrency 2
std::async

part of high level concurrency
executes a callable object or a function in a separate thread
returns a std::future object that provides access to the result of the callable
include the header <future>

std::async has two overloads
one accepts a callable and arguments
the second accepts a launch policy, callable and arguments

std::launch::deferred - the task is executed synchronously
std::launch::async - the task is executed asynchronously

a call to std::async without a launch policy may not always create a new thread
- depends on the compiler implementation
- to force std::async to execute the task asynchronoulsy, use the asynch launch policy explicitly


if a new thread cannot be created with async launch policy, std::system_error exception is thrown

arguments can be specified in std::async
arguments are by default passed by value
to pass by reference, use the reference wrappers, std::ref or std::cref
to get a value from a task, simply return it from the corresponding function
this value is then available through the std::future object

std::future
used for communication between threads
has a shared state that can be accessed in a different thread
created through a std::promise object
- created by std::async, that directly returns a future object
- std::promise is an input channel
- std::future is the output channel
the thread that reads the shared state will wait until the future is ready (with the shared state)
promise/future pair allow safe data sharing between threads

p177 - launch policies

p178 - wait functions

p179 - using std::promise
promise:

provides a way to store a value or exception
this is called the shared state
this state can be accessed later from another thread through a future object
promise/future are two endpoints of a communication channel
one operation stores a value in a promise and the other operation will retrieve if through a future asynchonously
these operations are synchronized, and therefore, thread-safe
promise object can be used only once


